/**
 * Build Script: Sync HTML templates to TypeScript
 * This script reads HTML template files and converts them to TypeScript strings
 * for use in Cloudflare Workers environment
 */

const fs = require('fs');
const path = require('path');

const TEMPLATES_DIR = path.join(__dirname, '../templates');
const OUTPUT_FILE = path.join(__dirname, '../lib/template-handler.ts');

// Read all HTML template files
function readTemplates() {
  const templates = {};
  const templateFiles = fs.readdirSync(TEMPLATES_DIR)
    .filter(file => file.endsWith('.html'));

  for (const file of templateFiles) {
    const templateName = path.basename(file, '.html');
    const filePath = path.join(TEMPLATES_DIR, file);
    const content = fs.readFileSync(filePath, 'utf8');
    templates[templateName] = content;
    console.log(`‚úì Loaded template: ${templateName}`);
  }

  return templates;
}

// Escape backticks and other characters for TypeScript string literals
function escapeForTypeScript(str) {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\${/g, '\\${');
}

// Generate TypeScript file with embedded templates
function generateTypeScriptFile(templates) {
  const templateConstants = Object.entries(templates)
    .map(([name, content]) => {
      const escapedContent = escapeForTypeScript(content);
      return `const ${name.toUpperCase()}_TEMPLATE = \`${escapedContent}\`;`;
    })
    .join('\n\n');

  const templatesObject = Object.keys(templates)
    .map(name => {
      const constantName = name.toUpperCase().replace('-', '_') + '_TEMPLATE';
      return `      '${name}': ${constantName}`;
    })
    .join(',\n');

  return `/**
 * Template Handler: Utility for loading and rendering HTML templates
 * Handles template substitution for dynamic content
 * Auto-generated by build-templates.js - DO NOT EDIT MANUALLY
 */

interface TemplateData {
  [key: string]: string;
}

/**
 * Load and render an HTML template with data substitution
 * @param templateName - Name of the template file (without .html extension)
 * @param data - Object containing key-value pairs for template substitution
 * @returns Promise<string> - Rendered HTML content
 */
export async function renderTemplate(templateName: string, data: TemplateData = {}): Promise<string> {
  try {
    // Get template content
    const templateContent = await getTemplateContent(templateName);

    // Replace {{KEY}} placeholders with actual values
    let renderedContent = templateContent;
    for (const [key, value] of Object.entries(data)) {
      const placeholder = \`{{\${key.toUpperCase()}}}\`;
      renderedContent = renderedContent.replace(new RegExp(placeholder, 'g'), value);
    }

    return renderedContent;
  } catch (error) {
    console.error(\`[Template Handler] Error rendering template \${templateName}:\`, error);
    throw new Error(\`Failed to render template: \${templateName}\`);
  }
}

/**
 * Get template content
 */
async function getTemplateContent(templateName: string): Promise<string> {
  const templates: { [key: string]: string } = {
${templatesObject}
  };

  const template = templates[templateName];
  if (!template) {
    throw new Error(\`Template not found: \${templateName}\`);
  }

  return template;
}

// Embedded templates
${Object.entries(templates).map(([name, content]) => {
      const constantName = name.toUpperCase().replace('-', '_') + '_TEMPLATE';
      const escapedContent = escapeForTypeScript(content);
      return `const ${constantName} = \`${escapedContent}\`;`;
    }).join('\n\n')}
`;
}

// Main build function
function build() {
  console.log('üî® Building templates...');

  try {
    // Ensure templates directory exists
    if (!fs.existsSync(TEMPLATES_DIR)) {
      fs.mkdirSync(TEMPLATES_DIR, { recursive: true });
    }

    // Read templates
    const templates = readTemplates();

    if (Object.keys(templates).length === 0) {
      console.log('‚ö†Ô∏è  No template files found in', TEMPLATES_DIR);
      return;
    }

    // Generate TypeScript content
    const tsContent = generateTypeScriptFile(templates);

    // Write output file
    fs.writeFileSync(OUTPUT_FILE, tsContent, 'utf8');

    console.log('‚úÖ Templates built successfully!');
    console.log(`üìÅ Output: ${OUTPUT_FILE}`);
    console.log(`üìÑ Templates: ${Object.keys(templates).length}`);

  } catch (error) {
    console.error('‚ùå Build failed:', error);
    process.exit(1);
  }
}

// Run build if called directly
if (require.main === module) {
  build();
}

module.exports = { build };